---
title: "marchmadness2017"
output:
  pdf_document: default
  html_document: default
---
 
```{r}
library(plyr)
library(dplyr)
library(stringr)
library(ggplot2)
library(PlayerRatings)
library(car)
library(randomForest)
# library(gbm)
 
#inpath <- "C:/Users/jroberti/Git/mm2017/data/"
inpath <- "C:/Users/Amy/Documents/GitHub/mm2017/data/"
 
reg <- read.csv(paste0(inpath, "RegularSeasonCompactResults.csv"), stringsAsFactors = FALSE)
reg <- filter(reg, Season %in% c(2002:2013))


team <- read.csv(paste0(inpath, "Teams.csv"), stringsAsFactors = FALSE)
seasons <- read.csv(paste0(inpath, "Seasons.csv"), stringsAsFactors = FALSE)
 
tourney <- read.csv(paste0(inpath, "TourneyCompactResults.csv"), stringsAsFactors = FALSE)
tourney <- filter(tourney, Season %in% c(2002:2013))
 
head(reg)
 
```

## estimate ELO ratings

* Pilot 2016 season to see how to format and evaluate whether it makes sense...

```{r}
reg$Elo_Outcome <- ifelse(reg$Wscore - reg$Lscore>0, 1, 0)

season_end_ranks <- plyr::ddply(reg, .(Season), function(x){
  yo <- steph(x[,c("Daynum", "Wteam", "Lteam", "Elo_Outcome")], history=TRUE)
  return(yo$ratings)
})

season_end_ranks$key <- paste0(season_end_ranks$Season,"_",season_end_ranks$Player)

```

```{r}
reg2016 <- filter(reg, Season==2013)

# assign week of the year based on Daynum -- add year from 'Season'

## for the given day, assign the numeric week
week_idx <- data.frame(day=seq(1, 161, 7), week=seq(1,23, 1))
assign_week <- function(d, idx){
  for (i in 1:length(idx$day)){
    if (d >= idx[i,1] & d <= idx[i+1,1]){
      return(idx[i,2])
    }
  }
}
## tests
# assign_week(1, week_idx)
# assign_week(8, week_idx)
# assign_week(54, week_idx)
# assign_week(153, week_idx)
# sapply(seq(1,161,7), assign_week, idx=week_idx)

# assign 1 for win, 0 for loss, 0.5 for draw to team in left-most column
reg2016$Outcome <- ifelse(reg2016$Wscore - reg2016$Lscore>0, 1, 0)
reg2016$Week <- sapply(reg2016$Daynum, assign_week, week_idx)

# these are ratings where the 'week' paramter is incorrect (it thinks every new Daynum is a new week)
ranks2016_a <- steph(select(reg2016, Daynum, Wteam, Lteam, Outcome), history=TRUE)
# this uses the Daynum converted to week
ranks2016_b <- steph(select(reg2016, Week, Wteam, Lteam, Outcome), history=TRUE)

# they're different by 5-20 points; deviation is a lot different
head(ranks2016_a$ratings)
head(ranks2016_b$ratings)

dim(ranks2016$history)

# stash the weekly Elo rankings to use in weighting individual match ups
season_weekly_ranks <- plyr::ddply(reg, .(Season), function(x){
  yo <- steph(x[,c("Daynum", "Wteam", "Lteam", "Elo_Outcome")], history=TRUE)
  return(yo$ratings)
})

```

* Villanova is in top 5 for entire country (they won 2016 tourney)
* #1 ranked Kansas made it to Final Four, lost to Villanova
* Miami FL is in top 15, and made it to Elite Eight
* Maryland is in top 30, and made it to Elite Eight
* Oregon is in top 3, and made it to Final Four
* Oklahoma is in top 15 and made it to Final Four
* Texas A&M made it to Elite Eight and is in top 20
* Duke is in top 30, made it to Elite Eight
* Syracuse only potential 'Dark Horse', made it to Final Four but was not Ranked Top 30 for 2016 season

```{r}
reg$wdiff <- reg$Wscore - reg$Lscore
reg$ldiff <- reg$Lscore - reg$Wscore
 
## 'Stack' the data frames to quickly count wins and losses
wreg <- select(reg, Season, Daynum, Wteam, Wscore, Wloc, Numot, wdiff) %>% rename(team=Wteam,score=Wscore,loc=Wloc,diff=wdiff)
lreg <- select(reg, Season, Daynum, Lteam, Lscore, Wloc, Numot, ldiff) %>% rename(team=Lteam,score=Lscore,loc=Wloc,diff=ldiff)
outreg <- rbind(wreg,lreg)

## count wins and losses
outreg$outcome <- ifelse(outreg$diff > 0, "win", "loss")

proc_reg <- group_by(outreg, Season, team) %>%
  dplyr::summarise(totwin=sum(str_count(outcome, "win")),
                   totloss=sum(str_count(outcome, "loss")),
                   wdiff_avg=mean(ifelse(diff>0, as.numeric(diff), 0)),
                   ldiff_avg=mean(ifelse(diff<0, as.numeric(diff), 0)),
                   score_avg=mean(score),
                   score_sd=sd(score),
                   wdiff_sd=sd(ifelse(diff>0, as.numeric(diff),0)),
                   ldiff_sd=sd(ifelse(diff<0, as.numeric(diff),0))
                   )

head(proc_reg)
```

### Determine end of season performance

```{r}
## how to pull the last N number of games
season_end_wins <- outreg %>% 
  group_by(Season, team) %>% 
  arrange(Daynum) %>% 
  top_n(6, wt=Daynum) %>% 
  #summarize(last6_win=sum(Outcome))
  summarize(last6_win=sum(str_count(outcome, "win")))

# ## check the results to make sure top_n() is working as expected...
# tail(season_end_wins, 20)
# filter(outreg, Season==2016, team==1447) %>% arrange(Daynum) 

season_end_wins$key <- paste0(season_end_wins$Season,"_",season_end_wins$team)
```

## Process Tournament Data

```{r}
tourney$wdiff <- tourney$Wscore - tourney$Lscore
tourney$ldiff <- tourney$Lscore - tourney$Wscore

wtourney <- select(tourney, Season, Daynum, Wteam, Wscore, Wloc, Numot, wdiff) %>% rename(team=Wteam,score=Wscore,loc=Wloc,diff=wdiff)
ltourney <- select(tourney, Season, Daynum, Lteam, Lscore, Wloc, Numot, ldiff) %>% rename(team=Lteam,score=Lscore,loc=Wloc,diff=ldiff)

outtourney <- rbind(wtourney,ltourney)
outtourney$outcome <- ifelse(outtourney$diff > 0, "win", "loss")

# 

proc_tourn <- group_by(outtourney, Season, team) %>%
  dplyr::summarise(totwin=sum(str_count(outcome, "win")), 
                   totloss=sum(str_count(outcome, "loss")),
                   wdiff_avg=mean(ifelse(diff>0, as.numeric(diff), 0)),
                   ldiff_avg=mean(ifelse(diff<0, as.numeric(diff), 0)),
                   score_avg=mean(score),
                   score_sd=sd(score),
                   wdiff_sd=sd(ifelse(diff>0, as.numeric(diff),0)),
                   ldiff_sd=sd(ifelse(diff<0, as.numeric(diff),0))
                   )

## rename "T_" == tournament data
names(proc_tourn) <- paste0("T_",names(proc_tourn))
```


## Execute a merge so we can model tourney_outcomes ~ reg_season_data

```{r}
## make keys to match the data between the two tables
proc_reg$key <- paste0(proc_reg$Season,"_",proc_reg$team)
proc_tourn$key <- paste0(proc_tourn$T_Season,"_",proc_tourn$T_team)

## the tournament results should be the left table, because the proc_reg table 
## has results of ALL teams that played (i.e. even teams that didn't make it to the tourney)
model_dat <- merge(proc_tourn, proc_reg, by.x="key", by.y="key")
model_dat <- merge(model_dat, season_end_wins)
model_dat <- merge(model_dat, season_end_ranks)

model_dat$win_pct <- model_dat$totwin / (model_dat$totwin + model_dat$totloss)
```

## EDA via Scatterplot Matrix

```{r}
car::scatterplotMatrix(~T_totwin+Rating+win_pct+wdiff_avg+ldiff_avg+score_avg+score_sd+wdiff_sd+ldiff_sd+last6_win, data = model_dat)
```

## Explore different Tournament response variables (i.e. what's a good metric for how a team performs in the tournament?)

```{r}
m1 <- randomForest(T_totwin~win_pct+Rating+wdiff_sd+score_sd+score_avg+Deviation, data = model_dat)
m2 <- randomForest(T_wdiff_avg~win_pct+Rating+wdiff_sd+score_sd+score_avg+Deviation, data = model_dat)

```

## try some viz for tourney data

```{r}
ggplot(model_dat, aes(win_pct, T_totwin)) + geom_point() 
ggplot(model_dat, aes(T_totwin,wdiff_avg)) + geom_point()
ggplot(model_dat, aes(T_totwin,wdiff_sd)) + geom_point()
```

### Better Methods

* The real question is probably not "How many games will a team win in the tournament?"
* Rather, we're interested in "what metrics represent a winning team?"
* Or more broadly, "when two teams go head to head, how do you determine who will win?" 
* In other words, we should be looking at teams that win in general (at least, teams that make it to the tournament), not just teams that win games in the tournament (which doesn't give us a way to estimate whether a team will win or lose a given game)

### What makes a good, winning team?

```{r}
m3 <- randomForest(win_pct~Rating+wdiff_sd+wdiff_avg+score_avg+score_sd+score_avg+Deviation+last6_win+ldiff_sd+ldiff_avg, data = model_dat)

varImpPlot(m3)

# partialPlot(m3, model_dat, "ldiff_avg")
# partialPlot(m3, model_dat, "wdiff_avg")
# partialPlot(m3, model_dat, "Rating")
```


### Next steps

* Weight regular season wins; not all wins are equal ('weighted_wins')
* Weighted_wins can perhaps give us an idea of how well a team plays against challenging teams
* weighted_wins ~ reg_season_vars might be a better way to predict game outcomes